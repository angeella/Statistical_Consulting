---
title: "Report Stat_Consulting"
author: "Angela Andreella"
date: "16/05/2020"
output: html_document
---

```{r setup, include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
#load package
source("Angela/packages.R")

#load variables
load("Angela/Data/var.RData")

#load data
load("Data/db_with_R0.RData")

#add R0 ML
dat <- add_R0_ML(df)

#add Cluster Silvia aligned
#datMIO <- dat
#load("Silvia/")
uno <- c( "CAN", "DEU", "GBR", "SWE", "USA")
due <- c("IRL", "IRN", "ITA", "NLD", "TUR")
tre <- c( "AUT", "BEL", "CHE", "DNK", "ESP", "FIN", "FRA", "NOR","RUS")
quattro <- c("KOR", "SGP")
cinque <- c("GRC", "PRT", "ROU", "SAU")
states_to_sel <- c(uno,due,tre,quattro,cinque)
#states_to_sel <- levels(uno)
#length(states_to_sel) #28
#dat <- datMIO
datA <- dat %>% filter(id %in% states_to_sel)

datA$Clusters <- ifelse(datA$id %in% uno, "Cl1", 
                        ifelse(datA$id %in% due, "Cl2", 
                               ifelse(datA$id %in% tre, "Cl3", 
                                      ifelse(datA$id %in% quattro, "Cl4", 
                                             "Cl5"))))
dat <- datA

#Some steps 
#dat$dateF <- factor(dat$date)
dat$Clusters <- factor(dat$Clusters)
#dat$EPOCH <- ifelse(dat$date <= "2020-02-15", "First",
#                    ifelse(dat$date <= "2020-03-15", "Second", "Third"))
#dat$EPOCH <- as.factor(dat$EPOCH)
dat <- 
  dat %>% arrange(id, date) %>%
  group_by(id) %>%
  mutate(R0_lag = dplyr::lag(R0, n = 14, default = NA))

dat_shape <- dat %>%
  left_join(dat %>%
              filter(confirmed >= 0) %>%
              group_by(id) %>%
              summarise(date.start=min(date)),
            by="id") %>%
  mutate(date2=date-date.start) %>%
  as.data.frame()
```

# Motivation

So, the aim is to understand how the lockdown policies influences the changing of the index $R0$, the reproduction number. However, this index has a non linear trend, then we want to capture this changing in the three epoches expressed in the following plot:

```{r}
dat %>% ggplot(aes(x=date, y=R0_lag, group=Clusters, color=Clusters)) +
  geom_smooth() + geom_vline(xintercept = as.Date("2020-02-15"),linetype="dashed") + geom_vline(xintercept = as.Date("2020-03-15"),linetype="dashed") + scale_x_date(date_labels = "%b %d")

```

considering the clusters computed previously. We takes $3$ intervals, start to 15 of Febraury, 15 Febraury to 15 March, 15 March end. 

However, if we consider the aligned data respect to the first 30 confirmed cases, we have the following situation:

```{r}
dat_shape$date2 <- as.integer(dat_shape$date2)
dat_shape %>% ggplot(aes(x=date2, y=R0_lag, group=Clusters, color=Clusters)) + geom_smooth()
```

Also, we lag the R0 respect to $14$ days, in order to consider the influences of the restrictions imposed at time $t$ on $R0$ at time $t+14$, in order to make a correct impact.

# Exploratory Analysis

So, we have the following variables to consider:

Economic ones:

```{r}
var_EC
```

Demographic ones:

```{r}
var_FIX
```

Health ones:

```{r}
var_HS
```

plus the number of tests conducted.

```{r}
cormat <- round(cor(dat_shape[,c(var_EC, "R0_lag", var_FIX, var_HS)],use = "na.or.complete"),6)
dat_cor <- melt(cormat)

p <- ggplot(data = dat_cor, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile()

ggplotly(p)

```

## Economic variables

```{r}
p <- dat_shape %>% ggplot(aes(x=date, y=ox.E1_Income.support, group=Clusters, color=Clusters)) +
  geom_smooth() 

ggplotly(p)
```

```{r}
p <- dat_shape %>% ggplot(aes(x=R0_lag, y=ox.E1_Income.support)) +
  geom_smooth() 

ggplotly(p)
```


```{r}
p <- dat_shape %>% ggplot(aes(x=date2, y=ox.E2_Debt.contract.relief, group=Clusters, color=Clusters)) +
  geom_smooth() 

ggplotly(p)
```

Fai policorica per queste due var ordinali economiche!

```{r}
pca_EC <- polychoric(dat_shape[,var_EC[1:2]])
p3 <- principal(r = pca_EC$rho, nfactors = 1) 
dat_shape$EC_pca <- as.matrix(dat_shape[,var_EC[1:2]]) %*% p3$weights
```

```{r}
p <- dat_shape %>% ggplot(aes(x=date2, y=EC_pca, group=Clusters, color=Clusters)) +
  geom_smooth() 

ggplotly(p)
```

```{r}
p <- dat_shape %>% ggplot(aes(x=date2, y=ox.E3_Fiscal.measures, group=Clusters, color=Clusters)) +
  geom_smooth() 

ggplotly(p)

dat_shape$ox.E3_Fiscal.measures_log <- log(dat_shape$ox.E3_Fiscal.measures +1)
```

Usa in log scale

```{r}
p <- dat_shape %>% ggplot(aes(x=date2, y=ox.E4_International.support, group=Clusters, color=Clusters)) +
  geom_smooth() 

ggplotly(p)

dat_shape$ox.E4_International.support <- ifelse(is.na(dat$ox.E4_International.support), 0, dat_shape$ox.E4_International.support)
dat_shape$ox.E4_International.support_log <- log(dat_shape$ox.E4_International.support +1)

```

Usa in log scale, sostiuisci NA con 0.

```{r}
p <- dat_shape %>% ggplot(aes(x=date2, y=mkt_close, group=Clusters, color=Clusters)) +
  geom_smooth() 

ggplotly(p)
```

```{r}
p <- dat_shape %>% ggplot(aes(x=date2, y=mkt_volume, group=Clusters, color=Clusters)) +
  geom_smooth() 

ggplotly(p)
```


## Fix variables

```{r}
p <- ggplot(dat_shape, aes(x=Clusters, y=log(pop), fill=Clusters)) + geom_boxplot() 


ggplotly(p)

dat_shape$pop_log <- log(dat_shape$pop +1)

```

passa al log

```{r}
p <- ggplot(dat_shape, aes(x=Clusters, y=pop_65, fill=Clusters)) + geom_boxplot() 


ggplotly(p)
```

```{r}
p <- ggplot(dat_shape, aes(x=Clusters, y=pop_age, fill=Clusters)) + geom_boxplot() 


ggplotly(p)
```

facciamo una pca di queste due

```{r}
pca_age <- princomp(is.na(dat_shape[,var_FIX[2:3]]), cor = TRUE)
dat_shape$pca_age <- dat_shape[,var_FIX[2]]
dat_shape$pca_age <- ifelse(is.na(dat_shape$pca_age), NA, pca_age$scores)
```


```{r}
p <- ggplot(dat_shape, aes(x=Clusters, y=pop_density, fill=Clusters)) + geom_boxplot() 

dat_shape$pop_density_log <- log(dat_shape$pop_density + 1)
ggplotly(p)
```

Togli Singapore. e metti log

```{r}
p <- ggplot(dat_shape, aes(x=Clusters, y=hosp_beds, fill=Clusters)) + geom_boxplot() 


ggplotly(p)


```

```{r}
p <- ggplot(dat_shape, aes(x=Clusters, y=pop_death_rate, fill=Clusters)) + geom_boxplot() 


ggplotly(p)
```

```{r}
p <- ggplot(dat, aes(x=Clusters, y=gdp, fill=Clusters)) + geom_boxplot() 


ggplotly(p)
dat_shape$gdp_log <- log(dat_shape$gdp + 1)

```

fai il log

```{r}
p <- ggplot(dat_shape, aes(x=Clusters, y=health_exp, fill=Clusters)) + geom_boxplot() 


ggplotly(p)
```

```{r}
p <- ggplot(dat_shape, aes(x=Clusters, y=health_exp_oop, fill=Clusters)) + geom_boxplot() 


ggplotly(p)
```

## Health variables

```{r}
p <- dat_shape %>% ggplot(aes(x=date2, y=ox.H4_Emergency.investment.in.healthcare, group=Clusters, color=Clusters)) +
  geom_smooth() 

ggplotly(p)
```

metti log

```{r}
p <- dat_shape %>% ggplot(aes(x=date2, y=ox.H5_Investment.in.vaccines, group=Clusters, color=Clusters)) +
  geom_smooth() 

ggplotly(p)
```

fai la pca con queste due


# Model

The data are observed for each country nested within date. 

- Two-level model: the units of analysis (Level 1), countries, are nested within randomly sampled clusters (Level 2), date;

- The variability of the data comes from nested sources;

- The Intraclass Correlation Coefficient (ICC) is equal to 0.46.

```{r}

ICCest(date2, R0_lag, dat_shape) #0.5268934
ICCest(EPOCH, R0, dat_shape) #0.5268934

abc<-aggregate(R0 ~date2, dat_shape, mean)
bdata <- dat_shape
bdata <- merge(bdata,abc,by="date2")
bdata$colorBox <- ifelse(bdata$R0.y>= mean(na.omit(bdata$R0.x)), "#56B4E9", "#009E73")

bdata$date2 <- as.factor(bdata$date2)
ggplot(bdata, aes(x=date2, y=R0.x, fill = colorBox)) +
    geom_boxplot() +
  scale_color_manual(values=rainbow(6))+ theme(legend.position="none",axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

```

**How to choose the random and fixed part?**

The problem is much more complicated than in linear regression because selection on the covariance structure is not straightforward due to computational issues and boundary problems arising from positive semidefinite constraints on covariance matrices.

-Conditional AIC (Package cAIC4): The conditional AIC is also appropriate for choosing between a simple null model without any random effects and a complex model incorporating random effects,

-Boostrap (R Package pbkrtest): Model comparison of nested models using parametric bootstrap methods. Implemented for some commonly applied model types.

```{r}
df <- as.data.frame(aggregate(R0 ~date2, dat_shape, length)) %>% arrange(desc(R0))
ggplot(dat_shape[(dat_shape$date2 %in% df$date2),], aes(x = hosp_beds, y = R0, group = date2)) +
  geom_smooth(method = "lm", se = FALSE, color = "darkgrey") +
  geom_point(alpha = 0.3, size = 3,color="blue") +
  facet_wrap(~date2) +
  theme_minimal()
#ggsave("Exploratory.pdf")
```

Variability on health_exp, gdp, mkt_close, mkt_volume, hosp_beds, pop_65, pop_age, pop_death_rate (not to much between first and third), 

```{r}
dat_shape$Clusters <- recode_factor(dat_shape$Clusters,
                              "Cl1" = "testing_based",
                              "Cl2" = "restrinctionsStrong_testingMild_based",
                              "Cl3" = "mild_levels_all",
                              "Cl4" = "testing_tracing_based",
                              "Cl5" = "restriction_tracingMild")
```

```{r}
var_EC <- c("EC_pca", var_EC[5:6], "ox.E3_Fiscal.measures_log", "ox.E4_International.support_log")

var_FIX <- c("pca_age", "pop_log", "pop_density_log", "hosp_beds", "pop_death_rate", "gdp_log", "health_exp")

var_HS <- "pca_hs"
f <- as.formula(paste("R0_lag", "~", paste(c(var_EC), collapse=" + "), 
                  #   "+", paste(c(var_FIX), collapse=" + "),
                      "+", paste(c(var_HS), collapse=" + "),
                      "+", "tests + Clusters",
                      "+ (1 |date2) + (1|id)"))

model <- lmer(f, data = dat_shape,REML=FALSE)
summary(model)
```

da aggiustare le pca :( errore

```{r}
load("Angela/Data/var.RData")
var_EC <- c(var_EC[c(1:2,5:6)], "ox.E3_Fiscal.measures_log", "ox.E4_International.support_log")

var_FIX <- c( "pop_65","pop_age", "pop_log", "pop_density_log", "hosp_beds", "pop_death_rate", "gdp_log", "health_exp")
dat_shape2 <- dat_shape %>% filter(date2 >= 0 )
f1 <- as.formula(paste("R0_lag", "~", paste(c(var_EC[c(2,4)]), collapse=" + "), 
                      "+", paste(c(var_FIX[c(2,4,8)]), collapse=" + "),
                      "+", paste(c(var_HS[2]), collapse=" + "),
                      "+", "tests + Clusters",
                      "+ (1 |date) + (1|id/Clusters)"))

model1 <- lmer(f1, data = dat_shape, REML=FALSE)

summary(model1)

f2 <- as.formula(paste("R0_lag", "~", paste(c(var_EC), collapse=" + "), 
                      "+", paste(c(var_FIX), collapse=" + "),
                      "+", paste(c(var_HS), collapse=" + "),
                      "+", "tests + Clusters",
                      "+ (1 |date2)"))

model2 <- lmer(f2, data = dat_shape, REML=FALSE)
summary(model2)
cAIC(model1)
cAIC(model2)

#togliamo l id visto che é var 0 e stesso cAIC

f3 <- as.formula(paste("R0_lag", "~", paste(c(var_EC[c(1,2,3,4)]), collapse=" + "),   
                      "+", paste(c(var_FIX[c(1,5,6,8)]), collapse=" + "),
                      "+", paste(c(var_HS[1]), collapse=" + "),
                      "+", "tests + Clusters",
                      "+ (1 + ox.E3_Fiscal.measures_log|date2)"))

model3 <- lmer(f3, data = dat_shape, REML=FALSE)
summary(model3)

f4 <- as.formula(paste("R0_lag", "~", paste(c(var_EC[c(1,2,4)]), collapse=" + "), 
                      "+", paste(c(var_FIX[c(2,4,5,8)]), collapse=" + "),
                      "+", paste(c(var_HS[2]), collapse=" + "),
                      "+", "Clusters",
                      "+ (1 |date2)"))

model4 <- lmer(f4, data = dat_shape, REML=FALSE)
summary(model4)

KRmodcomp(model3,model4)

#Continuiamo con model3

heatmap(as.matrix(vcov(model3)))
```

```{r}
plot_model(model1, type = "pred", terms = c("Clusters"))
plot_model(model3)
```


# Interpretation

```{r}
comparison <- c("testing_based - restrinctionsStrong_testingMild_based = 0",
                "testing_based - mild_levels_all = 0",
                "testing_based - testing_tracing_based = 0",
                "testing_based - restriction_tracingMild = 0",
                "restrinctionsStrong_testingMild_based - mild_levels_all = 0",
                "restrinctionsStrong_testingMild_based - testing_tracing_based = 0",
                "restrinctionsStrong_testingMild_based - restriction_tracingMild = 0",
                "mild_levels_all - testing_tracing_based = 0",
                "mild_levels_all - restriction_tracingMild = 0",
                "testing_tracing_based - restriction_tracingMild = 0")

test<-multcomp::glht(model1, linfct = mcp(Clusters = comparison),adjusted="holm")
summary(test)
```

```{r}
eff <- data.frame(effect("Clusters", model1))
#eff$Group <- factor(eff$Group,levels = c("cnt","fep","scz", "bipo"))

ggplot(eff, aes(x=Clusters, y=fit)) + 
  geom_errorbar(aes(ymin=lower, ymax=upper), width=.1) +
  geom_line(aes(group = 1)) + 
  geom_point(aes(x=reorder(Clusters, upper, desc), y=fit))+
  xlab("Clusters") + ylab("R0")
```

```{r}
world <- ne_countries(scale = "medium", returnclass = "sf")
world$id <- world$iso_a3

dat$R0fit <- ifelse(dat$Clusters == "tracing", eff$fit[1],
                    ifelse(dat$Clusters == "restriction_tracing", eff$fit[2],
                           ifelse(dat$Clusters == "testing", eff$fit[3],
                                  ifelse(dat$Clusters == "all", eff$fit[4],eff$fit[5]))))
datMap <- dat %>% filter(date == "15-02-2020")

datMap <- left_join(world, dat[,c("id","R0fit")], by="id")
datMap$R0fit <- as.factor(datMap$R0fit)
datMap$R0fit <- recode_factor(datMap$R0fit, "1.39317567222177" = "Tracing_Testing_1_39",
                              "2.09680419720344" = "All_2_1",
                              "2.29670265012321" = "Restriction_Tracing_2_3",
                              "2.65766476793349" = "Testing_2_65",
                              "3.47023144232237" = "Tracing_3_47")
ggplot(data = datMap) + geom_sf(aes(fill = R0fit)) + scale_color_ordinal()

```

